# 단위 테스트

단위 테스트는 소프트웨어 개발에서 일반적으로 사용하는 테스트 중 하나로, 개별적인 코드 단위(하나의 기능을 하는 코드)가 의도한 대로 작동하는지 확인하는 과정입니다.

단위 테스트를 통해 개별 코드의 오류를 조기 발견하고, 이를 수정하여 전체적인 소프트웨어 품질을 향상시킬 수 있습니다. 이를 위해 테스트 케이스를 작성하여, 각각 코드 단위가 정확한 입출력을 통해 동작하는지 확인합니다.

일반적으로 단위테스트를 활용하는 방법은 다음과 같습니다.

- 단위 테스트를 코드로 작성합니다.
- 소프트웨어 코드를 변경할 때마다 테스트 코드를 자동으로 실행합니다.
- 테스트가 실패할 경우 버그나 오류가 있는 코드 영역을 빠르게 분리할 수 있습니다.

![테스트 피라미드](assets/테스트%20피라미드.png)

마틴 파울러가 제시한 테스트 피라미드입니다. 각 단계는 인수테스트 -> 통합테스트 -> 단위테스트로 구성되는데 피라미드에서 하단에 위치할수록 더 많은 테스트코드를 작성해야 함을 나타냅니다. (피라미드 상단으로 갈수록 테스트 코드를 작성하기 위한 비용이 높아지기 때문입니다.)

## 단위 테스트 전략

단위 테스트를 만들려면 몇 가지 기본적인 방법에 따라 모든 테스트 사례를 포함하도록 할 수 있습니다.

- **논리검사** :시스템이 올바른 계산을 수행하며 정확하고 예상되는 입력이 주어진 코드를 통해 올바른 경로를 따르나요? 코드를 통한 모든 경로가 주어진 입력에 의해 처리되나요?
- **경계검사** : 주어진 입력에 대해 시스템은 어떻게 반응하나요? 일반적인 입력, 극단적 경우(edge case) 또는 잘못된 입력에 어떻게 반응하나요?
- **오류처리** : 입력에 오류가 있을 때 시스템은 어떻게 반응하나요? 사용자에게 다른 입력을 요구하는 메시지가 표시되나요? 소프트웨어가 충돌하나요?
- **객체지향 검사** : 코드를 실행하여 영구 객체의 상태가 변경되면 객체가 올바르게 업데이트되나요?

## 효과적인 단위 테스트를 위한 원칙

효과적인 단위 테스트 전략을 위해서 몇 가지 중요한 원칙을 따라야 합니다.

- 테스트 대상 코드의 동작을 명확히 이해하고, 이를 기반으로 테스트 케이스를 작성해야 합니다. 이때 구현을 테스트해서는 안 됩니다.
- 테스트는 가능한 한 작은 단위로 분리하며 각 기능을 독립적으로 검증해야 합니다. 이를 위해 목(mock) 객체나 스텁(stub)을 사용하여 외부 의존성을 제거하고, 테스트 대상 코드의 동작만을 집중적으로 검증할 수 있습니다.
- 테스트 코드는 유지 보수가 용이해야 합니다. 코드 베이스가 변경될 때마다 테스트 코드도 함께 업데이트되어야 하므로, 테스트 코드의 가독성과 재사용성을 높이는 것이 중요합니다.
- 모든 경계 조건과 예외 상황을 테스트해야 합니다. 이는 소프트웨어가 예상치 못한 상황에서도 올바르게 동작하는지 확인하는 데 필수적입니다.
- 지속적인 테스트를 위해 자동화된 테스트 환경을 구축하는 것이 중요합니다. 이를 통해 개발 과정에서 지속적으로 코드의 품질을 검증할 수 있습니다.

## 단위 테스트의 구조 (AAA)

AAA 패턴은 준비(Arrange), 실행(Act), 검증 (Assert) 세 가지 단계로 테스트를 구조화하는 방법입니다. _BDD의 Given-When-Then과 유사합니다._

```ts
import { sum } from "./sum";

test("두 숫자를 더한 결과를 반환해야 한다", () => {
  // Arrange: 테스트 준비
  const operand1 = 1;
  const operand2 = 2;
  const expected = 3;

  // Act: 실제 함수 실행
  const result = sum(operand1, operand2);

  // Assert: 결과 확인
  expect(result).toBe(expected);
});
```

- Arrange : 준비 단계에서는 테스트에 필요한 대상과 의존성을 준비합니다.
- Act : 실행 단계에서는 SUT에서 메서드를 호출하고 준비된 의존성을 전달하며, 출력이 존재하면 출력값을 캡처합니다.
- Assert : 검증 단계에서는 결괏값을 검증합니다.

## 좋은 단위테스트

### 테스트 4대 요소

- 리팩터링 내성 : 테스트를 바꾸지 않고 기본 애플리케이션 코드를 리팩터링할 수 있는가
  - 거짓 양성: 기능은 잘 동작하는데 테스트가 깨지는 경우
- 빠른 피드백 : 코드의 변경마다 실행해야 하기 때문에 통과/실패에 대한 피드백에 즉각적으로 전달되어야 한다. _단위 테스트는 빠르게 실행되어야 한다._
- 회귀 방지 : 테스트가 가능한 한 많은 코드를 실행하는 것을 목표로 해야 한다.
  - 거짓 음성: 기능이 동작하지 않는데 테스트는 통과하는 경우
- 유지보수성 : 테스트가 얼마나 이해하기 어려운가?, 테스트가 얼마나 실행하기 어려운가? 의존성이 높다면 실행하기 어려운 테스트

이를 통해 이상적인 테스트는 `회귀방지`, `리팩터링내성`, `빠른피드백`, `유지보수성`에 대해 점수를 내야 합니다.

위 4가지 요소는 곱연산으로 계산되며 하나라도 0이 되면 전체가 0이됩니다. 즉, 특성이 0이 되지 않도록 서로 조금씩 인정하는 것이 최선의 전략입니다. (리팩터링 내성은 점수가 0 아님 1, 양극단에 위치함으로 최대한 리팩터링 내성을 많이 갖는 것을 목표로 합니다. 그다음 버그를 얼마나 발견하는지, 얼마나 빠른지 순서를 취하게 됩니다.)

### 블랙박스 테스트

단위 테스트는 블랙박스 테스트를 기본으로 선택해야 합니다. 즉, 코드의 내부 구조를 전혀 모르는 것처럼 테스트코드를 작성해야 합니다.

- **블랙박스 테스트** : 소프트웨어 내부 구조나 작동 원리를 모르는 상태에서 소프트웨어의 동작을 검사하는 기법. 검사 진행에 있어서 코드나 내부 구조에 대한 정보 대신 요구사항 명세서, 설계도 등 대외적으로 공개된 사항을 통해 검사를 진행하는 테스팅 기법

  - **동등분할 기법(Equivalence Partitioning)** : 입력 데이터에 따른 결괏값을 테스트할때 사용 소프트웨어에서 요구하는 입력 데이터를 그룹화해 해당 그룹에 속하는 값으로 결과를 비교.
    - 예시) 숫자 입력 필드를 1부터 100까지 유효한 입력으로 허용하는 프로그램. 동등 분할 기법을 이용해 1-100(유효), 0 이하의 숫자(무효), 101 이상의 숫자(무효)로 나눠 테스트
  - **경계값 분석 기법(Boundary Value Analysis)** : 경계가 뚜렷한 입력 데이터에 따른 동작을 검사할 때 사용되는 기법, 입력 조건의 경계에 해당하는 값들에서 에러가 발생할 확률이 높다는 점을 이용해 검사.
    - 예시) 숫자 입력 필드를 1부터 100까지 유효한 입력으로 허용하는 프로그램. 경곗값 분석을 통해 0, 1, 100, 101 등 경곗값을 통해 테스트
  - **오류 예측 기법(Error Guessing)** : 각 기능에 대한 제약 조건을 위반함으로써 생길 수 있는 오류들을 추측해 검사.
    - 예시) 사용자가 입력 필드에 특수문자나 부정확한 문자를 입력할 때 발생할 수 있는 오류를 예측
  - **원인 결과 그래프 기법(Cause Effect Graph)** : 원인 결과 그래프를 통해 요구사항 명세를 입출력 조건 간의 논리적 관계로 표현하고 이를 기반으로 테스트 케이스를 만듦.
  - **결정 테이블 (Decision Table)** : 논리적 조건이나 상황에서 입력 조건과 결과를 참, 거짓으로 표현해 조합을 만들고 테스트를 작성.
    - 예시) 사용자의 특정 입력에 대한 시스템이 특정 상태로 반응하는 프로그램. 테이블을 통해 모든 조건과 그에 따른 결과를 정리하고 이를 테스트로 작성
  - **상태 전이 (State Transition)** : 시스템의 상태가 변화함에 따라 상태가 다른 결과물을 도출할 때 그 과정을 테스트 케이스로 작성.
    - 예시) 사용자의 로그인 여부에 따른 상태 전이를 다양한 시나리오로 테스트

- **화이트박스 테스트** : 소프트웨어 혹은 제품의 내부 구조, 동작을 세밀하게 검사하는 테스트 방식, 내부 소스코드를 테스트하는 기법으로 보다 개발자 관점의 단위 테스팅 기법
  - **문장 검증** : 프로그램의 코드가 전체 다 수행되는지 검증
  - **분기 검증** : 프로그램의 로직에 있는 분기를 최소 하번 실행하는지 검증
  - **경로 검증** : 각 조건들이 개별적으로 참/거짓이 한 번 실행될 수 있도록 검증
  - **조건 검증** : 조건 문의 모든 조건식을 만족하는 경우와 만족하지 않는 경우 검증

### DRY보다 DAMP하게 작성해야 합니다.

DAMP는 **Descriptive And Meaningful Phrase**의 약자로 **서술적이고 의미 있는 문구**를 뜻합니다. 즉, 테스트 코드는 중복을 줄이기 보다 더 서술적이고 의미 있게, 각 테스트가 독립적으로 격리될 수 있도록 작성해야 합니다.

_이를 위해 **beforeEach**보다는 **테스트 픽스처 함수**를 고려해 볼 수 있습니다._

> 테스트 픽스처 함수에 대한 예시는 [여기](https://jojoldu.tistory.com/611)에서 더 자세히 알아볼 수 있습니다.

### 구현이 아닌 결과를 검증해야 합니다.

외부 의존성에 대해 Mock, Spy, Stub를 사용하다 보면, 결과가 아닌 구현을 검증하는 경우가 발생합니다. 또한 Stub과의 상호작용을 검증하는 것은 일반적으로 취약한 테스트를 야기하는 안티 패턴이므로 피해야 합니다. 내부 구현을 검증하는 테스트를 작성 할수록 테스트 코드는 리팩토링 내성을 잃게 됩니다.

따라서 결과를 검증하기 위해 모의 객체의 메서드 호출 여부를 검증하지 말고, 실제 실행 후 상태를 검증해야 합니다.

또한 도메인 로직을 유출하지 마세요. 기댓값에 구현이 노출되어서는 안됩니다.

```ts
const add = (a: number, b: number) => a + b;

//Bad
test("add", () => {
  expect(add(1, 2)).toBe(1 + 2); // 구현이 노출된 테스트
});

//Good
test("add", () => {
  expect(add(1, 2)).toBe(3);
});
```

> 더 자세한 예시는 [여기](https://jojoldu.tistory.com/614)에서 알아볼 수 있습니다.

파라미터 테스트를 활용하세요.

```ts
const add = (a: number, b: number) => a + b;

test.each([
  [1, 2, 3],
  [2, 3, 5],
  [3, 4, 7],
])("add(%i, %i) should return %i", (a, b, expected) => {
  expect(add(a, b)).toBe(expected);
});
```

![테스트 결과](assets/파라미터테스트%20결과.png)

비공개 메서드를 테스트하지 않습니다. 비공개 메서드는 공개 API를 통해 간접적으로 테스트해야 합니다. 이때 비공개 메서드의 복잡도가 높아 공개 API로 테스트가 불가능하다면, 코드의 품질이 낮거나 추상화 수준을 고려해야 합니다.

### 문서화 가능한, 읽기 좋은 테스트를 작성하세요.

테스트 코드는 문서화의 이점이 있습니다. 또한 테스트 코드도 유지 보수가 필요한 코드입니다. 흐름을 파악하기 어렵고 불명확한 테스트 코드는 코드의 확장과 리팩터링을 더욱 어렵게 합니다.

- 타인을 위해 테스트를 이해하기 위한 모든 정보를, 테스트 케이스 본문에 담아야 합니다.
- 테스트의 구조화를 진행합니다. (GWT, AAA)
- 테스트 내부의 코드가 많아진다면 테스트 팩토리, 빌더, 헬퍼 메서드를 사용을 고려합니다.
- 비개발자도 이해할 수 있는 명세를 작성합니다.

> 테스트 메서드 이름에 대해서는 [여기](https://jojoldu.tistory.com/732)에서 알아볼 수 있습니다.
